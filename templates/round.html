
    {% extends "base.html" %}

{% block title %}Tournament Round{% endblock %}

{% block content %}


    <meta charset="utf-8">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    
    <style>
      body { font-family: system-ui, sans-serif; max-width: 1100px; margin: 2rem auto; }
      nav { margin-bottom: 1rem; }
      table { width: 100%; border-collapse: collapse; margin-top: 1rem; }
      th, td { border: 1px solid #ccc; padding: .5rem; text-align: center; }
      th { background: #f0f0f0; }
      .elo-pos { color: green; font-weight: bold; }
      .elo-neg { color: red; font-weight: bold; }

      .btn-confirm {
        margin-top: 1rem;
        padding: .75rem 1.5rem;
        font-size: 1rem;
        background: #4CAF50;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        width: 100%;
      }
      .btn-confirm:hover { background: #45a049; }

      .btn-deck {
        padding: .3rem .6rem;
        font-size: 0.9rem;
        background: #007bff;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        margin: 2px;
      }
      .btn-deck:hover { background: #0069d9; }

      /* Grey variant for outside Top Cut */
      .btn-deck-grey {
        background: #6c757d;
        color: #f8f9fa;
      }
      .btn-deck-grey:hover { background: #5a6268; }

      .icon { margin-right: 4px; }

      /* Modal */
      .modal {
        display: none;
        position: fixed;
        z-index: 1000;
        left: 0; top: 0;
        width: 100%; height: 100%;
        background-color: rgba(0,0,0,0.5);
      }
      .modal-content {
        background-color: #fff;
        margin: 5% auto;
        padding: 20px;
        border-radius: 6px;
        width: 400px;
        max-height: 90vh;
        overflow-y: auto;
      }
      .modal-content h3 { margin-top: 0; }
      .modal-content input, .modal-content textarea {
        width: 100%;
        margin-bottom: 1rem;
        padding: .5rem;
        border: 1px solid #ccc;
        border-radius: 4px;
      }

      /* Deck Name Dropdown */
      .deck-name-wrapper {
        position: relative;
        width: 100%;
        margin-bottom: 1rem;
      }
      
      .deck-name-dropdown {
        display: none;
        position: absolute;
        top: 100%;
        left: 0;
        right: 0;
        max-height: 200px;
        overflow-y: auto;
        background: white;
        border: 1px solid #ccc;
        border-top: none;
        border-radius: 0 0 4px 4px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        z-index: 1001;
      }
      
      .deck-name-dropdown-item {
        padding: 0.5rem;
        cursor: pointer;
        border-bottom: 1px solid #eee;
      }
      
      .deck-name-dropdown-item:hover {
        background-color: #f0f0f0;
      }
      
      .deck-name-dropdown-item:last-child {
        border-bottom: none;
      }
      
      .deck-name-create {
        padding: 0.5rem;
        font-style: italic;
        color: #007bff;
        cursor: pointer;
        border-top: 2px solid #007bff;
      }
      
      .deck-name-create:hover {
        background-color: #e7f3ff;
      }

      .close {
        float: right;
        font-size: 1.2rem;
        cursor: pointer;
      }
      tr.highlight { background-color: #ffeeba; font-weight: bold; }

      .side-panel {
        flex:0 0 200px;
        background:#f9f9f9;
        padding:1rem;
        border:1px solid #ccc;
        border-radius:6px;
      }

  .deck-editor-wrap {
    position: relative;
    border: 1px solid #ccc;
    border-radius: 4px;
    min-height: 200px;
    background: #fff;
    /* prevent width changes due to padding/border */
    box-sizing: border-box;
    overflow: hidden;
  }


.deck-editor {
  border: 1px solid #ccc;
  border-radius: 4px;
  min-height: 200px;
  max-height: 400px;
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Courier New", monospace;
  font-size: 14px;
  line-height: 1.5;
  padding: .5rem;
  white-space: pre-wrap;
  word-wrap: break-word;
  overflow-y: auto;
  outline: none;
  box-sizing: border-box;
}

/* Highlight spans behave exactly like text */
.hl-valid,
.hl-invalid,
.hl-dup {
  display: inline;
  font: inherit;
  line-height: inherit;
  vertical-align: baseline;
  padding: 0;
  margin: 0;
}

.hl-valid   { color: #2e7d32; }
html.dark-mode .deck-editor .hl-valid { color: #66bb6a !important; }
html.dark-mode .deck-editor span.hl-valid { color: #66bb6a !important; }
.hl-invalid { background: #f8d7da; color: #c0392b; }
.hl-not-legal { background: #fff3cd; color: #856404; }
.quantity-error { color: #c0392b; font-weight: bold; }
.hl-sideboard { 
  color: #ffffff !important; 
  font-weight: bold; 
  display: block;
  padding-bottom: 0.5rem;
  border-bottom: 2px solid #888;
  margin-bottom: 0.5rem;
}
html.dark-mode .deck-editor .hl-sideboard { color: #ffffff !important; }
html.dark-mode .deck-editor span.hl-sideboard { color: #ffffff !important; }


      .side-panel h3 { margin-top:0; }

      .option-group { display: flex; flex-direction: column; gap: .5rem; }
      .option input[type="radio"] { display: none; }
      .option span {
        display: block;
        padding: .6rem 1rem;
        border: 1px solid #ccc;
        border-radius: 6px;
        cursor: pointer;
        background: #f9f9f9;
        transition: all 0.2s ease;
        text-align: center;
      }
      .option input[type="radio"]:checked + span {
        background: #4CAF50;
        color: white;
        border-color: #4CAF50;
        font-weight: bold;
      }
      .option span:hover { background: #e0e0e0; }

      .btn-toggle-rounds {
        padding: .75rem 1.5rem;
        font-size: 1rem;
        background: #007bff;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        margin-bottom: 1rem;
        transition: background 0.2s ease;
        display: inline-flex;
        align-items: center;
        gap: 0.5rem;
      }
      .btn-toggle-rounds:hover { background: #0056b3; }
      .btn-toggle-rounds.expanded { background: #0056b3; }
      .btn-toggle-rounds .material-icons {
        font-size: 20px;
        transition: transform 0.3s ease;
      }
      .btn-toggle-rounds.expanded .material-icons {
        transform: rotate(180deg);
      }

      #allRoundsSection {
        display: none;
        margin-top: 2rem;
        padding: 1.5rem;
        border: 2px solid #007bff;
        border-radius: 6px;
        background: #f8f9fa;
      }

      #allRoundsSection.visible {
        display: block;
      }

      .round-group {
        margin-bottom: 2rem;
        padding: 1rem;
        background: white;
        border: 1px solid #ddd;
        border-radius: 4px;
      }

      .round-group h3 {
        margin-top: 0;
        color: #2c3e50;
        border-bottom: 2px solid #007bff;
        padding-bottom: 0.5rem;
        cursor: pointer;
        user-select: none;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .round-group h3:hover {
        background: #f8f9fa;
      }

      .round-toggle-icon {
        font-size: 1.2rem;
        transition: transform 0.3s ease;
      }

      .round-toggle-icon.collapsed {
        transform: rotate(-90deg);
      }

      .round-content {
        max-height: 1000px;
        overflow: hidden;
        transition: max-height 0.3s ease, opacity 0.3s ease;
        opacity: 1;
      }

      .round-content.collapsed {
        max-height: 0;
        opacity: 0;
      }

      .round-group table {
        width: 100%;
        margin-top: 1rem;
        table-layout: fixed;
      }

      .round-group th, .round-group td {
        padding: 0.75rem;
        text-align: center;
        border: 1px solid #ddd;
        word-wrap: break-word;
        overflow-wrap: break-word;
      }

      .round-group th {
        background: #f0f0f0;
      }

      .match-winner {
        background-color: #cfe2ff;
        font-weight: bold;
      }

      .elo-match-pos { color: green; font-weight: bold; }
      .elo-match-neg { color: red; font-weight: bold; }

      /* Editing mode styles */
      .editable-match {
        transition: background-color 0.2s ease;
      }

      .editable-cell {
        cursor: pointer;
        transition: all 0.2s ease;
        position: relative;
        user-select: none;
      }

      .editable-cell:hover {
        background-color: #e7f3ff !important;
        box-shadow: inset 0 0 0 2px #4dabf7;
      }

      .editable-cell:active {
        transform: scale(0.98);
      }

      /* Selected winner cell - enhanced highlighting */
      .editable-cell.match-winner {
        background-color: #d0e8ff !important;
        box-shadow: inset 0 0 0 3px #0d6efd;
        font-weight: bold;
      }

      .editable-cell.match-winner:hover {
        background-color: #b8dcff !important;
        box-shadow: inset 0 0 0 3px #0a58ca;
      }

      .btn-winner {
        padding: 0.4rem 0.8rem;
        font-size: 1.2rem;
        background: #e0e0e0;
        color: #666;
        border: 2px solid #ccc;
        border-radius: 4px;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .btn-winner:hover {
        background: #d0d0d0;
        border-color: #999;
      }

      .btn-winner.active {
        background: #4CAF50;
        color: white;
        border-color: #4CAF50;
        font-weight: bold;
      }

      /* Player name buttons in edit mode */
      .player-name-btn {
        background: none;
        border: none;
        padding: 0;
        margin: 0;
        font: inherit;
        color: inherit;
        cursor: pointer;
        width: 100%;
        text-align: center;
        transition: all 0.2s ease;
        display: block;
      }

      .player-name-btn:hover {
        background-color: #e7f3ff;
        box-shadow: inset 0 0 0 2px #4dabf7;
      }

      .player-name-btn:active {
        transform: scale(0.98);
      }

      .player-name-btn.winner {
        font-weight: bold;
      }

      .changes-pending {
        position: fixed;
        bottom: 20px;
        right: 20px;
        background: #ff9800;
        color: white;
        padding: 1rem 1.5rem;
        border-radius: 6px;
        box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        z-index: 1000;
        display: none;
      }

      .changes-pending.visible {
        display: block;
      }

      .btn-save-changes {
        margin-top: 1rem;
        padding: .75rem 1.5rem;
        font-size: 1rem;
        background: #4CAF50;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        width: 100%;
      }
      .btn-save-changes:hover { background: #45a049; }

      /* Loading overlay for deck validation */
      .deck-loading-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(255, 255, 255, 0.9);
        display: none;
        align-items: center;
        justify-content: center;
        flex-direction: column;
        gap: 1rem;
        z-index: 10;
        border-radius: 4px;
      }

      .deck-loading-overlay.active {
        display: flex;
      }

      .deck-spinner {
        border: 4px solid #f3f3f3;
        border-top: 4px solid #007bff;
        border-radius: 50%;
        width: 40px;
        height: 40px;
        animation: spin 1s linear infinite;
      }

      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }

      .deck-loading-text {
        font-size: 1rem;
        color: #333;
        font-weight: 500;
      }

      /* Tournament Header Form Styling */
      .tournament-header-form {
        background: transparent;
        padding: 1.5rem 0;
        margin-bottom: 2rem;
      }

      .tournament-header-inputs {
        display: flex;
        gap: 1.5rem;
        align-items: flex-end;
      }

      .tournament-name-group {
        flex: 2;
      }

      .tournament-date-group {
        flex: 1;
        min-width: 200px;
      }

      .tournament-header-form label {
        display: block;
        color: #666;
        font-weight: 600;
        margin-bottom: 0.5rem;
        font-size: 0.85rem;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }

      .tournament-header-form input {
        width: 100%;
        padding: 0.75rem 1rem;
        border: 2px solid #ddd;
        border-radius: 8px;
        font-size: 1rem;
        background: white;
        transition: all 0.3s ease;
        box-sizing: border-box;
      }

      .tournament-header-form input:focus {
        outline: none;
        border-color: #4CAF50;
        box-shadow: 0 0 0 3px rgba(76, 175, 80, 0.1);
      }

      .tournament-name-group input {
        font-size: 1.5rem;
        font-weight: 600;
        color: #2c3e50;
      }

      .tournament-date-group input {
        font-size: 1rem;
        color: #2c3e50;
      }

      /* Dark mode support for tournament header */
      html.dark-mode .tournament-header-form label {
        color: #aaa;
      }

      html.dark-mode .tournament-header-form input {
        background: #2a2a2a;
        color: #e0e0e0;
        border-color: #444;
      }

      html.dark-mode .tournament-header-form input:focus {
        border-color: #4CAF50;
        box-shadow: 0 0 0 3px rgba(76, 175, 80, 0.2);
      }

      /* Enhanced Store Selector */
      .store-selector-wrapper {
        position: relative;
        margin-bottom: 1rem;
      }

      .store-selector-wrapper.required h3::after {
        content: " *";
        color: #d9534f;
      }

      .store-selector-wrapper.error .store-select-button {
        border-color: #d9534f;
        box-shadow: 0 0 0 3px rgba(217, 83, 79, 0.1);
      }

      .store-select-button {
        width: 100%;
        padding: 0.75rem 1rem;
        border: 2px solid #ddd;
        border-radius: 8px;
        font-size: 1rem;
        background: white;
        cursor: pointer;
        transition: all 0.3s ease;
        box-sizing: border-box;
        text-align: left;
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.75rem;
      }

      .store-select-content {
        display: flex;
        align-items: center;
        gap: 0.75rem;
        flex: 1;
      }

      .store-select-image {
        width: 32px;
        height: 32px;
        object-fit: contain;
        border-radius: 4px;
      }

      .store-select-placeholder {
        width: 32px;
        height: 32px;
        background: #e0e0e0;
        border-radius: 4px;
        display: flex;
        align-items: center;
        justify-content: center;
        color: #999;
        font-size: 1rem;
      }

      .store-select-button:hover {
        border-color: #4CAF50;
      }

      .store-select-button.active {
        border-color: #4CAF50;
        box-shadow: 0 0 0 3px rgba(76, 175, 80, 0.1);
      }

      .store-dropdown {
        display: none;
        position: absolute;
        top: 100%;
        left: 0;
        right: 0;
        max-height: 400px;
        overflow-y: auto;
        background: white;
        border: 2px solid #4CAF50;
        border-radius: 8px;
        margin-top: 0.25rem;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        z-index: 1000;
      }

      .store-dropdown.active {
        display: block;
      }

      .store-option {
        display: flex;
        align-items: center;
        padding: 0.75rem 1rem;
        cursor: pointer;
        transition: background 0.2s ease;
        border-bottom: 1px solid #f0f0f0;
      }

      .store-option:last-child {
        border-bottom: none;
      }

      .store-option:hover {
        background: #f8f9fa;
      }

      .store-option.selected {
        background: #e8f5e9;
      }

      .store-option-image {
        width: 40px;
        height: 40px;
        object-fit: contain;
        margin-right: 1rem;
        border-radius: 4px;
      }

      .store-option-placeholder {
        width: 40px;
        height: 40px;
        margin-right: 1rem;
        background: #e0e0e0;
        border-radius: 4px;
        display: flex;
        align-items: center;
        justify-content: center;
        color: #999;
        font-size: 1.2rem;
      }

      .store-option-text {
        flex: 1;
      }

      .store-option-name {
        font-weight: 600;
        color: #2c3e50;
      }

      .store-option-location {
        font-size: 0.85rem;
        color: #666;
        margin-top: 0.25rem;
      }

      .store-error-message {
        color: #d9534f;
        font-size: 0.85rem;
        margin-top: 0.5rem;
        display: none;
      }

      .store-selector-wrapper.error .store-error-message {
        display: block;
      }

      /* Dark mode store selector */
      html.dark-mode .store-select-button {
        background: #2a2a2a;
        color: #e0e0e0;
        border-color: #444;
      }

      html.dark-mode .store-dropdown {
        background: #2a2a2a;
        border-color: #4CAF50;
      }

      html.dark-mode .store-option {
        border-bottom-color: #333;
      }

      html.dark-mode .store-option:hover {
        background: #333;
      }

      html.dark-mode .store-option.selected {
        background: #1e3a1e;
      }

      html.dark-mode .store-option-name {
        color: #e0e0e0;
      }

      html.dark-mode .store-option-location {
        color: #aaa;
      }

      html.dark-mode .store-option-placeholder {
        background: #444;
      }
    </style>


    <form class="tournament-header-form" method="POST" action="{{ url_for('update_tournament_metadata', tid=tournament.id) }}">
      <input type="hidden" name="current_round" value="{{ round_num }}">
      <div class="tournament-header-inputs">
        <div class="tournament-name-group">
          <label for="tournament-name">Tournament Name</label>
          <input 
            type="text" 
            id="tournament-name" 
            name="tournament_name"
            value="{% if tournament.name %}{{ tournament.name }}{% else %}Tournament Round {{ round_num }}{% endif %}"
            placeholder="Enter tournament name"
            onchange="this.form.submit()">
        </div>
        <div class="tournament-date-group">
          <label for="tournament-date">Date</label>
          <input 
            type="date" 
            id="tournament-date" 
            name="tournament_date"
            value="{{ tournament.date }}"
            onchange="this.form.submit()"
            required>
        </div>
      </div>
    </form>

    {% if tournament.rounds > 1 %}
    <button id="toggleAllRoundsBtn" class="btn-toggle-rounds">
      <span class="material-icons">expand_more</span>
      <span>Round-by-Round Results</span>
    </button>
    {% endif %}

    <!-- All Rounds Expandable Section -->
    {% if tournament.imported_from_text or is_editing %}
    <div id="allRoundsSection">
      <h2>üìä Round-by-Round Results{% if is_editing %} - Click to Select Winners{% endif %}</h2>
      
      {% set matches_by_round = {} %}
      {% for match in all_matches %}
        {% if match.round_num not in matches_by_round %}
          {% set _ = matches_by_round.update({match.round_num: []}) %}
        {% endif %}
        {% if matches_by_round[match.round_num].append(match) %}{% endif %}
      {% endfor %}

      {% for round_num in matches_by_round|sort %}
        <div class="round-group">
          <h3 onclick="toggleRound(this)">
            <span>Round {{ round_num }}</span>
            <span class="round-toggle-icon collapsed">‚ñº</span>
          </h3>
          <div class="round-content collapsed">
          <table>
            <tr>
              <th style="width: 42%;">Player 1</th>
              <th style="width: 16%;">{% if is_editing %}Winner{% else %}Elo Œî{% endif %}</th>
              <th style="width: 16%;">{% if is_editing %}Winner{% else %}Elo Œî{% endif %}</th>
              <th style="width: 42%;">Player 2</th>
            </tr>
            {% for match in matches_by_round[round_num] %}
              {% set elo_data = per_round_elo_changes.get(round_num, {}).get(match.id, {'player1_elo_delta': 0, 'player2_elo_delta': 0, 'winner': 0}) if not is_editing else {} %}
              <tr data-match-id="{{ match.id }}" class="{% if is_editing %}editable-match{% endif %}">
                <td class="{% if is_editing and match.result in ['2-0', '2-1', '1-0'] %}match-winner{% endif %}{% if not is_editing and elo_data.winner == 1 %} match-winner{% endif %}">
                  {% if is_editing and match.player1_id %}
                    <button type="button" class="player-name-btn {% if match.result in ['2-0', '2-1', '1-0'] %}winner{% endif %}" onclick="selectWinner({{ match.id }}, 1)">
                      {{ match.player1.name }}
                    </button>
                  {% elif match.player1_id %}
                    {{ match.player1.name }}
                  {% else %}
                    <em>Bye</em>
                  {% endif %}
                </td>
                <td>
                  {% if is_editing %}
                    <button type="button" class="btn-winner {% if match.result in ['2-0', '2-1', '1-0'] %}active{% endif %}" 
                            onclick="selectWinner({{ match.id }}, 1)">‚úì</button>
                  {% elif elo_data.player1_elo_delta != 0 %}
                    <span class="{{ 'elo-match-pos' if elo_data.player1_elo_delta > 0 else 'elo-match-neg' }}">
                      {{ "+" if elo_data.player1_elo_delta > 0 else "" }}{{ elo_data.player1_elo_delta }}
                    </span>
                  {% else %}
                    ‚Äî
                  {% endif %}
                </td>
                <td>
                  {% if is_editing %}
                    <button type="button" class="btn-winner {% if match.result in ['0-2', '1-2', '0-1'] %}active{% endif %}" 
                            onclick="selectWinner({{ match.id }}, 2)">‚úì</button>
                  {% elif elo_data.player2_elo_delta != 0 %}
                    <span class="{{ 'elo-match-pos' if elo_data.player2_elo_delta > 0 else 'elo-match-neg' }}">
                      {{ "+" if elo_data.player2_elo_delta > 0 else "" }}{{ elo_data.player2_elo_delta }}
                    </span>
                  {% else %}
                    ‚Äî
                  {% endif %}
                </td>
                <td class="{% if is_editing and match.result in ['0-2', '1-2', '0-1'] %}match-winner{% endif %}{% if not is_editing and elo_data.winner == 2 %} match-winner{% endif %}">
                  {% if is_editing and match.player2_id %}
                    <button type="button" class="player-name-btn {% if match.result in ['0-2', '1-2', '0-1'] %}winner{% endif %}" onclick="selectWinner({{ match.id }}, 2)">
                      {{ match.player2.name }}
                    </button>
                  {% elif match.player2_id %}
                    {{ match.player2.name }}
                  {% else %}
                    <em>Bye</em>
                  {% endif %}
                </td>
              </tr>
            {% endfor %}
          </table>
          </div>
        </div>
      {% endfor %}
    </div>
    {% endif %}
{% if tournament.imported_from_text %}

  {% if tournament.premium %}
    <p style="color:gold; font-weight:bold; margin-top:0.5rem;">
      ‚òÖ This is a Premium Event ‚òÖ
    </p>
  {% endif %}


      <div style="display:flex; gap:2rem;">
        <!-- Standings table -->
        <div style="flex:1;">
          <h2>Final Standings (Preview)</h2>
          <div id="playersMeta" data-count="{{ players|length }}"></div>

          <table>
            <tr>
              <th>Rank</th>
              <th>Player</th>
              <th>Wins</th>
              <th>Draws</th>
              <th>Losses</th>
              <th>Points</th>
              <th>Elo Œî</th>
              <th>Deck</th>
            </tr>
            {% for s in standings %}
            {% set in_cut = (tournament.top_cut is not none) and (loop.index <= tournament.top_cut|int) %}

            <tr data-rank="{{ loop.index }}" class="{% if in_cut %}highlight{% endif %}">
              <td>{{ loop.index }}</td>
              <td>{{ s.player.name }}</td>
              <td>{{ s.wins }}</td>
              <td>{{ s.draws }}</td>
              <td>{{ s.losses }}</td>
              <td>{{ s.points }}</td>
              <td>
                <span class="{{ 'elo-pos' if s.elo_delta > 0 else 'elo-neg' if s.elo_delta < 0 else '' }}">
                  {{ s.elo_delta }}
                </span>
              </td>
<td>
  {% if s.deck %}
    <!-- Edit deck button (always blue) -->
    <button class="btn-deck"
            data-player-id="{{ s.player.id }}"
            data-player-name="{{ s.player.name|e }}"
            data-deck-name="{{ s.deck.name|e }}"
            data-deck-list="{{ s.deck.list_text|e }}"
            onclick="openDeckModal(this)">
      <span class="material-icons" style="font-size: 16px;">edit</span>Edit
    </button>
    <!-- Remove deck button (always blue) -->
    <form method="POST" action="{{ url_for('remove_deck') }}" style="display:inline;">
      <input type="hidden" name="player_id" value="{{ s.player.id }}">
      <input type="hidden" name="tournament_id" value="{{ tid }}">
      <button type="submit" class="btn-deck">
        <span class="material-icons" style="font-size: 16px;">delete</span>Remove
      </button>
    </form>
    
  {% else %}
    <!-- Add deck button: blue if in cut, grey if out -->
    <button class="btn-deck {% if not in_cut %}btn-deck-grey{% endif %}"
            data-player-id="{{ s.player.id }}"
            data-player-name="{{ s.player.name|e }}"
            onclick="openDeckModal(this)">
      <span class="material-icons" style="font-size: 16px;">add</span>Add Deck
    </button>
  {% endif %}
</td>


            </tr>
            {% endfor %}
          </table>
        </div>
{% if tournament.pending and current_user.is_authenticated and (current_user.is_admin or current_user.is_scorekeeper) %}
<div class="side-panel">
  <!-- New imported tournament awaiting confirmation -->
  <h3>Playoff Cut</h3>
  <form method="POST" action="{{ url_for('apply_top_cut', tid=tid) }}" class="topcut-form">
    <div class="option-group">
      <label class="option">
        <input type="radio" name="top_cut" value="" {% if not tournament.top_cut %}checked{% endif %}>
        <span>Auto</span>
      </label>

      {% if players|length >= 4 %}
      <label class="option">
        <input type="radio" name="top_cut" value="4" {% if tournament.top_cut == 4 %}checked{% endif %}>
        <span>TOP 4</span>
      </label>
      {% endif %}

      {% if players|length >= 8 %}
      <label class="option">
        <input type="radio" name="top_cut" value="8" {% if tournament.top_cut == 8 %}checked{% endif %}>
        <span>TOP 8</span>
      </label>
      {% endif %}

      {% if players|length >= 16 %}
      <label class="option">
        <input type="radio" name="top_cut" value="16" {% if tournament.top_cut == 16 %}checked{% endif %}>
        <span>TOP 16</span>
      </label>
      {% endif %}

      {% if players|length >= 32 %}
      <label class="option">
        <input type="radio" name="top_cut" value="32" {% if tournament.top_cut == 32 %}checked{% endif %}>
        <span>TOP 32</span>
      </label>
      {% endif %}
    </div>
    <button type="submit" class="btn-confirm">Confirm and Apply Elo</button>
  </form>

  {% if current_user.is_authenticated and (current_user.is_admin or current_user.is_scorekeeper) %}
  <div class="store-selector-wrapper required" id="storeWrapper">
    <h3>Store</h3>
    <button type="button" class="store-select-button" id="storeSelectBtn">
      <div class="store-select-content">
        <div id="storeSelectImage"></div>
        <span id="storeSelectText">Select a store...</span>
      </div>
      <span>‚ñº</span>
    </button>
    <input type="hidden" id="storeSelect" name="store_id" value="{{ tournament.store_id if tournament.store_id else '' }}">
    <div class="store-dropdown" id="storeDropdown">
      {% for store in stores %}
        <div class="store-option" data-store-id="{{ store.id }}" data-store-name="{{ store.name }}" data-store-location="{% if store.location %}{{ store.location }}{% if store.country %}, {{ store.country }}{% endif %}{% elif store.country %}{{ store.country }}{% endif %}">
          {% if store.image_url %}
            <img src="{{ url_for('static', filename=store.image_url) }}" class="store-option-image" alt="{{ store.name }}">
          {% else %}
            <div class="store-option-placeholder">üè™</div>
          {% endif %}
          <div class="store-option-text">
            <div class="store-option-name">{{ store.name }}</div>
            <div class="store-option-location">{% if store.location %}{{ store.location }}{% if store.country %}, {{ store.country }}{% endif %}{% elif store.country %}{{ store.country }}{% endif %}</div>
            {% if tournament.premium %}
              <div class="store-token-info" style="font-size: 0.75rem; color: #FFD700; margin-top: 0.25rem;">
                <i class="material-icons" style="font-size: 0.9rem; vertical-align: middle;">workspace_premium</i>
                Premium tokens: {{ store.premium_tokens }}
              </div>
            {% else %}
              <div class="store-token-info" style="font-size: 0.75rem; color: #4CAF50; margin-top: 0.25rem;">
                <i class="material-icons" style="font-size: 0.9rem; vertical-align: middle;">local_activity</i>
                Competitive tokens: {{ store.competitive_tokens }}
              </div>
            {% endif %}
          </div>
        </div>
      {% endfor %}
    </div>
    <div class="store-error-message">Please select a store before confirming</div>
  </div>
  <div id="storeStatus"></div>
  {% endif %}
</div>
{% elif is_editing and current_user.is_authenticated and (current_user.is_admin or current_user.is_scorekeeper) %}
<div class="side-panel">
  <!-- Editing existing confirmed tournament -->
  <form method="POST" action="{{ url_for('finalize_tournament_edit', tid=tid) }}">
    <button type="submit" class="btn-confirm" style="background: #28a745;">
      <span class="material-icons icon" style="vertical-align: middle;">check_circle</span>
      Finalize Tournament Edits
    </button>
  </form>

  <div class="store-selector-wrapper required" id="storeWrapperEdit">
    <h3>Store</h3>
    <button type="button" class="store-select-button" id="storeSelectBtnEdit">
      <div class="store-select-content">
        <div id="storeSelectImageEdit"></div>
        <span id="storeSelectTextEdit">Select a store...</span>
      </div>
      <span>‚ñº</span>
    </button>
    <input type="hidden" id="storeSelectEdit" name="store_id" value="{{ tournament.store_id if tournament.store_id else '' }}">
    <div class="store-dropdown" id="storeDropdownEdit">
      {% for store in stores %}
        <div class="store-option" data-store-id="{{ store.id }}" data-store-name="{{ store.name }}" data-store-location="{% if store.location %}{{ store.location }}{% if store.country %}, {{ store.country }}{% endif %}{% elif store.country %}{{ store.country }}{% endif %}">
          {% if store.image_url %}
            <img src="{{ url_for('static', filename=store.image_url) }}" class="store-option-image" alt="{{ store.name }}">
          {% else %}
            <div class="store-option-placeholder">üè™</div>
          {% endif %}
          <div class="store-option-text">
            <div class="store-option-name">{{ store.name }}</div>
            <div class="store-option-location">{% if store.location %}{{ store.location }}{% if store.country %}, {{ store.country }}{% endif %}{% elif store.country %}{{ store.country }}{% endif %}</div>
            {% if tournament.premium %}
              <div class="store-token-info" style="font-size: 0.75rem; color: #FFD700; margin-top: 0.25rem;">
                <i class="material-icons" style="font-size: 0.9rem; vertical-align: middle;">workspace_premium</i>
                Premium tokens: {{ store.premium_tokens }}
              </div>
            {% else %}
              <div class="store-token-info" style="font-size: 0.75rem; color: #4CAF50; margin-top: 0.25rem;">
                <i class="material-icons" style="font-size: 0.9rem; vertical-align: middle;">local_activity</i>
                Competitive tokens: {{ store.competitive_tokens }}
              </div>
            {% endif %}
          </div>
        </div>
      {% endfor %}
    </div>
    <div class="store-error-message">Please select a store before finalizing</div>
  </div>
  <div id="storeStatus"></div>
</div>
{% endif %}

<script>
{% if (tournament.pending or is_editing) and current_user.is_authenticated and (current_user.is_admin or current_user.is_scorekeeper) %}
// Store Selector
function initStoreSelector(buttonId, textId, imageId, dropdownId, hiddenInputId, wrapperId) {
  const button = document.getElementById(buttonId);
  const buttonText = document.getElementById(textId);
  const buttonImage = document.getElementById(imageId);
  const dropdown = document.getElementById(dropdownId);
  const hiddenInput = document.getElementById(hiddenInputId);
  const wrapper = document.getElementById(wrapperId);
  const options = dropdown.querySelectorAll('.store-option');
  
  let selectedStoreId = hiddenInput.value;
  
  // Show selected store in button
  function updateButtonText() {
    if (selectedStoreId) {
      const selectedOption = dropdown.querySelector(`[data-store-id="${selectedStoreId}"]`);
      if (selectedOption) {
        buttonText.textContent = selectedOption.dataset.storeName;
        
        // Update image
        const imgElement = selectedOption.querySelector('.store-option-image');
        const placeholderElement = selectedOption.querySelector('.store-option-placeholder');
        
        if (imgElement) {
          buttonImage.innerHTML = `<img src="${imgElement.src}" class="store-select-image" alt="${selectedOption.dataset.storeName}">`;
        } else if (placeholderElement) {
          buttonImage.innerHTML = '<div class="store-select-placeholder">üè™</div>';
        }
        
        wrapper.classList.remove('error');
        
        // Mark as selected
        options.forEach(opt => opt.classList.remove('selected'));
        selectedOption.classList.add('selected');
      }
    } else {
      buttonText.textContent = 'Select a store...';
      buttonImage.innerHTML = '';
    }
  }
  
  // Initialize
  updateButtonText();
  
  // Toggle dropdown on button click
  button.addEventListener('click', function(e) {
    e.stopPropagation();
    const isActive = dropdown.classList.contains('active');
    dropdown.classList.toggle('active');
    button.classList.toggle('active', !isActive);
  });
  
  // Select option on click
  options.forEach(option => {
    option.addEventListener('click', function() {
      selectedStoreId = this.dataset.storeId;
      hiddenInput.value = selectedStoreId;
      buttonText.textContent = this.dataset.storeName;
      dropdown.classList.remove('active');
      button.classList.remove('active');
      wrapper.classList.remove('error');
      
      // Mark as selected
      options.forEach(opt => opt.classList.remove('selected'));
      this.classList.add('selected');
      
      // Submit the store change
      submitStoreChange(selectedStoreId);
    });
  });
  
  // Close dropdown when clicking outside
  document.addEventListener('click', function(e) {
    if (!wrapper.contains(e.target)) {
      dropdown.classList.remove('active');
      button.classList.remove('active');
    }
  });
}

function submitStoreChange(storeId) {
  if (!storeId) return;
  
  const form = document.createElement('form');
  form.method = 'POST';
  form.action = "{{ url_for('set_tournament_store', tid=tid) }}";
  
  const input = document.createElement('input');
  input.type = 'hidden';
  input.name = 'store_id';
  input.value = storeId;
  form.appendChild(input);
  
  document.body.appendChild(form);
  form.submit();
}

// Validate store before form submit
function validateStore(wrapperId, hiddenInputId) {
  const wrapper = document.getElementById(wrapperId);
  const hiddenInput = document.getElementById(hiddenInputId);
  
  if (!hiddenInput.value) {
    wrapper.classList.add('error');
    return false;
  }
  return true;
}

// Initialize both selectors
{% if tournament.pending %}
if (document.getElementById('storeWrapper')) {
  initStoreSelector('storeSelectBtn', 'storeSelectText', 'storeSelectImage', 'storeDropdown', 'storeSelect', 'storeWrapper');
  
  // Add validation to confirm button
  const confirmBtn = document.querySelector('.btn-confirm');
  if (confirmBtn) {
    confirmBtn.addEventListener('click', function(e) {
      if (!validateStore('storeWrapper', 'storeSelect')) {
        e.preventDefault();
        return false;
      }
    });
  }
}
{% endif %}

{% if is_editing %}
if (document.getElementById('storeWrapperEdit')) {
  initStoreSelector('storeSelectBtnEdit', 'storeSelectTextEdit', 'storeSelectImageEdit', 'storeDropdownEdit', 'storeSelectEdit', 'storeWrapperEdit');
  
  // Add validation to finalize button
  const finalizeBtn = document.querySelector('form[action="{{ url_for("finalize_tournament_edit", tid=tid) }}"] button');
  if (finalizeBtn) {
    finalizeBtn.addEventListener('click', function(e) {
      if (!validateStore('storeWrapperEdit', 'storeSelectEdit')) {
        e.preventDefault();
        return false;
      }
    });
  }
}
{% endif %}
{% endif %}
</script>


      <!-- Deck Modal -->
      <div id="deckModal" class="modal">
        <div class="modal-content">
          <span class="close" onclick="closeDeckModal()">&times;</span>
          <h3 id="deckModalTitle">Add Deck</h3>
          <form id="deckForm" method="POST" action="{{ url_for('submit_deck') }}">
            <input type="hidden" name="player_id" id="deckPlayerId">
            <input type="hidden" name="tournament_id" value="{{ tid }}">
            <label>Deck Name</label>
            <div class="deck-name-wrapper">
              <input type="text" name="deck_name" id="deckName" autocomplete="off" placeholder="Search or create archetype...">
              <input type="hidden" id="deckNameConfirmed" value="false">
              <div id="deckNameDropdown" class="deck-name-dropdown"></div>
            </div>
<label>Deck List</label>
<div class="deck-editor-wrap">
  <div id="deckEditor" contenteditable="true" class="deck-editor" spellcheck="false" autocomplete="off"></div>
  <div id="deckLoadingOverlay" class="deck-loading-overlay">
    <div class="deck-spinner"></div>
    <div class="deck-loading-text">Checking Cards...</div>
  </div>
</div>

<!-- hidden textarea to submit raw text -->
<textarea name="deck_list" id="deckList" hidden></textarea>

<div id="deckErrors" style="color:red; margin-top:0.5rem;"></div>




            <button type="submit" class="btn-deck"><span class="material-icons" style="font-size: 16px;">save</span>Save</button>
          </form>
        </div>
      </div>

<script>
  // Modal open/close + populate
  function openDeckModal(button) {
    const playerId   = button.dataset.playerId;
    const playerName = button.dataset.playerName;
    const deckName   = button.dataset.deckName;
    const deckList   = button.dataset.deckList;

    const modal      = document.getElementById('deckModal');
    const title      = document.getElementById('deckModalTitle');
    const playerIdInput = document.getElementById('deckPlayerId');
    const deckNameInput = document.getElementById('deckName');
    const editor     = document.getElementById('deckEditor');
    const hidden     = document.getElementById('deckList');

    if (!modal || !title || !playerIdInput || !deckNameInput || !editor || !hidden) return;

    modal.style.display = 'block';
    title.textContent   = (deckName ? 'Edit Deck for ' : 'Add Deck for ') + playerName;
    playerIdInput.value = playerId;
    deckNameInput.value = deckName || '';

    const initial = deckList || '';
    
    // Properly structure the editor content
    editor.innerHTML = '';
    if (initial) {
      const lines = initial.split('\n');
      lines.forEach(line => {
        const div = document.createElement('div');
        const span = document.createElement('span');
        span.textContent = line;
        div.appendChild(span);
        editor.appendChild(div);
      });
      hidden.value = initial;
      validateAndHighlight();       // immediate validation for existing deck
    } else {
      // Empty editor with one empty line
      const div = document.createElement('div');
      const span = document.createElement('span');
      div.appendChild(span);
      editor.appendChild(div);
      hidden.value = '';
    }
  }

  function closeDeckModal() {
    const modal = document.getElementById('deckModal');
    if (modal) modal.style.display = 'none';
    const dropdown = document.getElementById('deckNameDropdown');
    if (dropdown) dropdown.style.display = 'none';
  }

  // Deck archetype dropdown functionality
  let archetypes = [];
  
  // Load archetypes from server
  async function loadArchetypes() {
    try {
      const response = await fetch("{{ url_for('get_deck_archetypes') }}");
      archetypes = await response.json();
    } catch (error) {
      console.error('Error loading archetypes:', error);
      archetypes = [];
    }
  }

  // Filter and display matching archetypes
  function showArchetypeDropdown(searchText) {
    const dropdown = document.getElementById('deckNameDropdown');
    const confirmedInput = document.getElementById('deckNameConfirmed');
    
    if (!dropdown) return;
    
    // Clear previous content
    dropdown.innerHTML = '';
    
    if (!searchText.trim()) {
      dropdown.style.display = 'none';
      return;
    }
    
    // Filter archetypes that match the search
    const filtered = archetypes.filter(arch => 
      arch.toLowerCase().includes(searchText.toLowerCase())
    );
    
    // Check if exact match exists
    const exactMatch = archetypes.find(arch => 
      arch.toLowerCase() === searchText.toLowerCase()
    );
    
    // Show existing archetypes
    if (filtered.length > 0) {
      filtered.forEach(arch => {
        const item = document.createElement('div');
        item.className = 'deck-name-dropdown-item';
        item.textContent = arch;
        item.onclick = () => {
          document.getElementById('deckName').value = arch;
          confirmedInput.value = 'true';
          dropdown.style.display = 'none';
        };
        dropdown.appendChild(item);
      });
    }
    
    // Show "Create new" option if no exact match
    if (!exactMatch && searchText.trim()) {
      const createItem = document.createElement('div');
      createItem.className = 'deck-name-create';
      createItem.textContent = `‚ú® Create new archetype: "${searchText}"`;
      createItem.onclick = () => {
        if (confirm(`Create new archetype "${searchText}"?`)) {
          confirmedInput.value = 'true';
          dropdown.style.display = 'none';
        }
      };
      dropdown.appendChild(createItem);
    }
    
    dropdown.style.display = filtered.length > 0 || !exactMatch ? 'block' : 'none';
  }

  // Setup deck name input listeners
  document.addEventListener('DOMContentLoaded', () => {
    loadArchetypes();
    
    const deckNameInput = document.getElementById('deckName');
    const confirmedInput = document.getElementById('deckNameConfirmed');
    const dropdown = document.getElementById('deckNameDropdown');
    
    if (deckNameInput) {
      // Show dropdown on input
      deckNameInput.addEventListener('input', (e) => {
        confirmedInput.value = 'false';
        showArchetypeDropdown(e.target.value);
      });
      
      // Show dropdown on focus
      deckNameInput.addEventListener('focus', (e) => {
        if (e.target.value) {
          showArchetypeDropdown(e.target.value);
        }
      });
      
      // Hide dropdown when clicking outside
      document.addEventListener('click', (e) => {
        if (!deckNameInput.contains(e.target) && !dropdown.contains(e.target)) {
          dropdown.style.display = 'none';
        }
      });
    }
  });

  window.onclick = function(event) {
    const modal = document.getElementById('deckModal');
    if (event.target === modal) closeDeckModal();
  }

  // Top Cut highlight logic
  function updateHighlight(topCut) {
    const rows = document.querySelectorAll("tr[data-rank]");
    rows.forEach(row => {
      const rank = parseInt(row.dataset.rank, 10);
      if (topCut && rank <= topCut) row.classList.add("highlight");
      else row.classList.remove("highlight");

      const addBtn = row.querySelector("button.btn-deck");
      if (addBtn && addBtn.textContent.includes("Add Deck")) {
        if (topCut && rank <= topCut) addBtn.classList.remove("btn-deck-grey");
        else addBtn.classList.add("btn-deck-grey");
      }
    });
  }

  const playersMetaEl = document.getElementById('playersMeta');
  const numPlayers    = playersMetaEl ? parseInt(playersMetaEl.dataset.count, 10) : 0;

  function defaultTopCut(n) {
    let cut = 0;
    if (n >= 9 && n <= 16) cut = 4;
    else if (n >= 17 && n <= 32) cut = 8;
    else if (n >= 33 && n <= 64) cut = 8;
    else if (n >= 65 && n <= 128) cut = 8;
    else if (n >= 129 && n <= 226) cut = 8;
    else if (n >= 217 && n <= 256) cut = 16;
    else if (n >= 257 && n <= 512) cut = 16;
    else if (n >= 513 && n <= 1024) cut = 32;
    else if (n >= 1025 && n <= 2048) cut = 32;
    return Math.min(cut, n);
  }

  document.querySelectorAll("input[name='top_cut']").forEach(input => {
    input.addEventListener("change", () => {
      const val = input.value;
      let topCut = val === "" ? defaultTopCut(numPlayers) : parseInt(val, 10);
      topCut = Math.min(topCut, numPlayers);
      updateHighlight(topCut);
    });
  });

  const checked = document.querySelector("input[name='top_cut']:checked");
  if (checked) {
    const val = checked.value;
    let topCut = val === "" ? defaultTopCut(numPlayers) : parseInt(val, 10);
    topCut = Math.min(topCut, numPlayers);
    updateHighlight(topCut);
  }

  // --- Inline validation inside editor (supports multiple cards per line) ---
  const editor     = document.getElementById("deckEditor");
  const hidden     = document.getElementById("deckList");
  const deckErrors = document.getElementById("deckErrors");

  function debounce(fn, delay = 300) {
    let t;
    return (...args) => { clearTimeout(t); t = setTimeout(() => fn(...args), delay); };
  }

  // Ensure each child is a DIV with a SPAN without rebuilding all text
  function normalizeEditor() {
    Array.from(editor.childNodes).forEach(node => {
      if (node.nodeType === Node.TEXT_NODE) {
        const div = document.createElement("div");
        const span = document.createElement("span");
        span.textContent = node.textContent;
        div.appendChild(span);
        editor.replaceChild(div, node);
      } else if (node.nodeType === Node.ELEMENT_NODE && node.tagName !== "DIV") {
        const div = document.createElement("div");
        const span = document.createElement("span");
        span.textContent = node.textContent;
        div.appendChild(span);
        editor.replaceChild(div, node);
      } else if (node.nodeType === Node.ELEMENT_NODE && node.tagName === "DIV") {
        let span = node.querySelector("span");
        if (!span) {
          span = document.createElement("span");
          span.textContent = node.textContent;
          node.innerHTML = "";
          node.appendChild(span);
        }
      }
    });
    if (!editor.firstChild) {
      const div = document.createElement("div");
      const span = document.createElement("span");
      div.appendChild(span);
      editor.appendChild(div);
    }
  }

  // Extract individual card names and quantities from a line
  function extractNamesFromLine(rawLine) {
    const trimmed = rawLine.trim();
    
    // Empty lines
    if (!trimmed) {
      return [];
    }
    
    // Sideboard marker line
    if (trimmed.toLowerCase() === 'sideboard' || trimmed.toLowerCase().startsWith('sideboard')) {
      return [{ name: '__SIDEBOARD__', count: 0, isSideboard: true }];
    }
    
    const tokens = trimmed.split(/\s+/);
    const cards = [];
    let currentCount = null;
    let currentName = [];

    for (let i = 0; i < tokens.length; i++) {
      const tok = tokens[i];
      const next = tokens[i + 1];

      if (/^-?\d+$/.test(tok)) {
        // count token: push any accumulated card before starting the next
        if (currentName.length > 0) {
          cards.push({ name: currentName.join(" "), count: currentCount || 1 });
          currentName = [];
        }
        currentCount = parseInt(tok);
        continue; // skip the count; next tokens belong to the name
      } else {
        currentName.push(tok);
        // if next token is a count or end of line, finalize current card
        if (!next || /^-?\d+$/.test(next)) {
          cards.push({ name: currentName.join(" "), count: currentCount || 1 });
          currentName = [];
          currentCount = null;
        }
      }
    }

    return cards
      .map(c => ({ name: c.name.trim(), count: c.count }))
      .filter(c => c.name.length > 0);
  }

  async function validateNames(cardNames) {
    const invalid = new Set();
    const notLegal = new Set();
    const cardData = new Map();
    
    for (const name of cardNames) {
      try {
        const resp = await fetch(`https://api.scryfall.com/cards/named?exact=${encodeURIComponent(name)}`);
        const card = await resp.json();
        if (card.object === "error") {
          invalid.add(name.toLowerCase());
        } else {
          cardData.set(name.toLowerCase(), card);
          // Check premodern legality
          if (card.legalities && card.legalities.premodern !== 'legal') {
            notLegal.add(name.toLowerCase());
          }
        }
      } catch {
        invalid.add(name.toLowerCase());
      }
    }
    return { invalid, notLegal, cardData };
  }

  async function validateAndHighlight(showLoading = false) {
    if (!editor || !hidden || !deckErrors) return;

    // Show loading overlay only if requested (for paste operations)
    const loadingOverlay = document.getElementById('deckLoadingOverlay');
    if (showLoading && loadingOverlay) loadingOverlay.classList.add('active');

    normalizeEditor();

    const lines = Array.from(editor.children).map(div => div.querySelector("span").textContent);
    hidden.value = lines.join("\n");

    // Build full list of names (no duplicate detection) and count sideboards
    const names = [];
    const seen = new Set();
    let sideboardCount = 0;

    const perLineCards = lines.map(line => extractNamesFromLine(line));
    for (const arr of perLineCards) {
      for (const card of arr) {
        if (card.isSideboard) {
          sideboardCount++;
          continue;
        }
        const key = card.name.toLowerCase();
        if (!seen.has(key)) {
          names.push(card.name);
          seen.add(key);
        }
      }
    }

    const { invalid, notLegal, cardData } = await validateNames(names);

    // Hide loading overlay
    if (loadingOverlay) loadingOverlay.classList.remove('active');

    // Check for quantity errors
    const basicLands = new Set(['plains', 'island', 'swamp', 'mountain', 'forest', 'wastes']);
    let hasQuantityError = false;
    const quantityErrors = [];
    
    // Check for multiple sideboards
    if (sideboardCount > 1) {
      hasQuantityError = true;
      quantityErrors.push('Multiple sideboard sections found - only one is allowed');
    }

    perLineCards.forEach(arr => {
      for (const card of arr) {
        // Skip sideboard markers
        if (card.isSideboard) continue;
        
        const key = card.name.toLowerCase();
        const isBasic = basicLands.has(key);
        const count = card.count;
        
        if (count <= 0 || count > (isBasic ? 999 : 4)) {
          hasQuantityError = true;
          if (count <= 0) {
            quantityErrors.push(`${card.name}: quantity must be at least 1`);
          } else {
            quantityErrors.push(`${card.name}: maximum 4 copies allowed (${count} specified)`);
          }
        }
      }
    });

    // Update save button state
    const saveBtn = document.querySelector('#deckForm button[type="submit"]');
    if (saveBtn) {
      if (invalid.size > 0 || hasQuantityError) {
        saveBtn.disabled = true;
        saveBtn.style.opacity = '0.5';
        saveBtn.style.cursor = 'not-allowed';
      } else {
        saveBtn.disabled = false;
        saveBtn.style.opacity = '1';
        saveBtn.style.cursor = 'pointer';
      }
    }

    // Decide line highlight: red if invalid or quantity error, yellow if not legal in premodern, green otherwise
    perLineCards.forEach((arr, i) => {
      // Check if this is a sideboard line
      if (arr.length > 0 && arr[0].isSideboard) {
        const span = editor.children[i].querySelector("span");
        // Mark as invalid if multiple sideboards exist
        if (sideboardCount > 1) {
          span.className = "hl-invalid";
        } else {
          span.className = "hl-sideboard";
        }
        return;
      }
      
      let isInvalid = false;
      let isNotLegal = false;
      let hasQtyError = false;
      
      for (const card of arr) {
        const key = card.name.toLowerCase();
        const isBasic = basicLands.has(key);
        const count = card.count;
        
        if (invalid.has(key)) {
          isInvalid = true;
          break;
        }
        if (count <= 0 || count > (isBasic ? 999 : 4)) {
          hasQtyError = true;
        }
        if (notLegal.has(key)) {
          isNotLegal = true;
        }
      }
      
      let cls = "hl-valid";
      if (isInvalid || hasQtyError) {
        cls = "hl-invalid";
      } else if (isNotLegal) {
        cls = "hl-not-legal";
      }

      const span = editor.children[i].querySelector("span");
      
      // Handle quantity errors by wrapping the number in a span
      if (hasQtyError && !isInvalid) {
        const text = span.textContent;
        const match = text.match(/^(-?\d+)\s+(.+)$/);
        if (match) {
          span.innerHTML = `<span class="quantity-error">${match[1]}</span> ${match[2]}`;
        }
      }
      
      if (span.className !== cls) span.className = cls;
    });

    // Errors list for invalid names and legality warnings
    deckErrors.innerHTML = "";
    
    // Quantity errors
    if (quantityErrors.length > 0) {
      quantityErrors.forEach(err => {
        const div = document.createElement("div");
        div.style.color = "#c0392b";
        div.textContent = err;
        deckErrors.appendChild(div);
      });
    }
    
    // Invalid card names
    if (invalid.size > 0) {
      const done = new Set();
      for (const nm of names) {
        const key = nm.toLowerCase();
        if (invalid.has(key) && !done.has(key)) {
          const div = document.createElement("div");
          div.textContent = `${nm} ‚Üí not found (exact match)`;
          deckErrors.appendChild(div);
          done.add(key);
        }
      }
    }
    
    // Not legal in premodern
    if (notLegal.size > 0) {
      const done = new Set();
      for (const nm of names) {
        const key = nm.toLowerCase();
        if (notLegal.has(key) && !done.has(key)) {
          const div = document.createElement("div");
          div.style.color = "#856404";
          div.textContent = `${nm} is not legal in premodern`;
          deckErrors.appendChild(div);
          done.add(key);
        }
      }
    }
  }

  const debouncedValidate = debounce(validateAndHighlight, 300);

  if (editor) {
    normalizeEditor();
    editor.addEventListener("input", debouncedValidate);
    editor.addEventListener("blur", validateAndHighlight);
    editor.addEventListener("keydown", e => {
      if (e.key === "Enter") {
        setTimeout(() => normalizeEditor(), 0);
      }
    });

  // üëá Add this paste handler here
  editor.addEventListener("paste", e => {
    e.preventDefault();
    const text = (e.clipboardData || window.clipboardData).getData("text");
    const lines = text.replace(/\r/g, "").split("\n");

    // Clear existing content
    editor.innerHTML = "";

    // Insert each line as its own div/span
    lines.forEach(line => {
      const div = document.createElement("div");
      const span = document.createElement("span");
      span.textContent = line;
      div.appendChild(span);
      editor.appendChild(div);
    });

    // After paste, normalize and validate immediately WITH loading overlay
    normalizeEditor();
    validateAndHighlight(true);  // showLoading = true
  });

  // Form submission validation
  const deckForm = document.getElementById('deckForm');
  if (deckForm) {
    deckForm.addEventListener('submit', (e) => {
      const deckNameInput = document.getElementById('deckName');
      const confirmedInput = document.getElementById('deckNameConfirmed');
      const deckName = deckNameInput ? deckNameInput.value.trim() : '';
      
      // Check if deck name is provided
      if (!deckName) {
        e.preventDefault();
        alert('Please enter a deck name.');
        return false;
      }
      
      // Check if it's a new archetype that hasn't been confirmed
      const isExisting = archetypes.some(arch => 
        arch.toLowerCase() === deckName.toLowerCase()
      );
      
      if (!isExisting && confirmedInput.value !== 'true') {
        e.preventDefault();
        if (confirm(`Create new archetype "${deckName}"?`)) {
          confirmedInput.value = 'true';
          deckForm.submit();
        }
        return false;
      }
      
      return true;
    });
  }
}

  // --- Toggle All Rounds Section ---
  const toggleBtn = document.getElementById('toggleAllRoundsBtn');
  const allRoundsSection = document.getElementById('allRoundsSection');

  if (toggleBtn && allRoundsSection) {
    toggleBtn.addEventListener('click', () => {
      allRoundsSection.classList.toggle('visible');
      toggleBtn.classList.toggle('expanded');
    });
  }

  // --- Toggle Individual Rounds ---
  function toggleRound(headerElement) {
    const content = headerElement.nextElementSibling;
    const icon = headerElement.querySelector('.round-toggle-icon');
    
    if (content && icon) {
      content.classList.toggle('collapsed');
      icon.classList.toggle('collapsed');
    }
  }

  // Editing mode: track changes and update winners
  const pendingChanges = {};

  function selectWinner(matchId, playerNum) {
    // Toggle winner selection
    const currentWinner = pendingChanges[matchId] || null;
    
    if (currentWinner === playerNum) {
      // Clicking same player deselects (draw)
      delete pendingChanges[matchId];
    } else {
      // Select new winner
      pendingChanges[matchId] = playerNum;
    }

    // Update visual feedback
    updateMatchDisplay(matchId);
    
    // Show/hide save indicator
    updateChangesIndicator();
  }

  function updateMatchDisplay(matchId) {
    const row = document.querySelector(`tr[data-match-id="${matchId}"]`);
    if (!row) return;

    const player1Cell = row.querySelector('td:nth-child(1)');
    const player2Cell = row.querySelector('td:nth-child(4)');
    const btn1 = row.querySelector('td:nth-child(2) button');
    const btn2 = row.querySelector('td:nth-child(3) button');

    // Reset all
    player1Cell.classList.remove('match-winner');
    player2Cell.classList.remove('match-winner');
    btn1.classList.remove('active');
    btn2.classList.remove('active');

    // Apply new selection
    const winner = pendingChanges[matchId];
    if (winner === 1) {
      player1Cell.classList.add('match-winner');
      btn1.classList.add('active');
    } else if (winner === 2) {
      player2Cell.classList.add('match-winner');
      btn2.classList.add('active');
    }
  }

  function updateChangesIndicator() {
    const hasChanges = Object.keys(pendingChanges).length > 0;
    let indicator = document.getElementById('changesIndicator');
    
    if (!indicator && hasChanges) {
      // Create indicator
      indicator = document.createElement('div');
      indicator.id = 'changesIndicator';
      indicator.className = 'changes-pending visible';
      indicator.innerHTML = `
        <div style="font-weight: bold; margin-bottom: 0.5rem;">
          ${Object.keys(pendingChanges).length} change(s) pending
        </div>
        <button onclick="saveChanges()" class="btn-save-changes">
          Save All Changes
        </button>
      `;
      document.body.appendChild(indicator);
    } else if (indicator) {
      if (hasChanges) {
        indicator.querySelector('div').textContent = `${Object.keys(pendingChanges).length} change(s) pending`;
      } else {
        indicator.remove();
      }
    }
  }

  function saveChanges() {
    if (Object.keys(pendingChanges).length === 0) return;

    // Send changes to backend
    fetch('{{ url_for("update_match_results", tid=tid) }}', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ changes: pendingChanges })
    })
    .then(response => response.json())
    .then(data => {
      if (data.success) {
        // Reload to show updated standings
        window.location.reload();
      } else {
        alert('Error saving changes: ' + (data.error || 'Unknown error'));
      }
    })
    .catch(error => {
      alert('Error saving changes: ' + error);
    });
  }



</script>




    {% else %}
      <h2>Enter Matches for Round {{ round_num }}</h2>
      <form method="POST">
        <table>
          <tr>
            <th>Player 1</th>
            <th>Player 2</th>
            <th>Result</th>
          </tr>
          {% for i in range(1, (players|length + 1)//2 + 1) %}
          <tr>
            <td>
              <select name="player1_{{ i }}">
                <option value="">-Select Player-</option>
                {% for p in players %}
                  <option value="{{ p.id }}">{{ p.name }}</option>
                {% endfor %}
                {% if (players|length) % 2 == 1 %}
                  <option value="bye">Bye</option>
                {% endif %}
              </select>
            </td>
            <td>
              <select name="player2_{{ i }}">
                <option value="">-Select Player-</option>
                {% for p in players %}
                  <option value="{{ p.id }}">{{ p.name }}</option>
                {% endfor %}
                {% if (players|length) % 2 == 1 %}
                  <option value="bye">Bye</option>
                {% endif %}
              </select>
            </td>
            <td>
              <select name="result_{{ i }}">
                <option value="2-0">2-0</option>
                <option value="2-1">2-1</option>
                <option value="1-2">1-2</option>
                <option value="0-2">0-2</option>
                <option value="1-1">1-1</option>
                <option value="1-0">1-0</option>
                <option value="0-1">0-1</option>
              </select>
            </td>
          </tr>
          {% endfor %}
        </table>
        <button type="submit">Submit Round {{ round_num }}</button>
      </form>
    {% endif %}

  {% endblock %}

