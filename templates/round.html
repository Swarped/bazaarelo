
    {% extends "base.html" %}

{% block title %}Tournament Round{% endblock %}

{% block content %}


    <meta charset="utf-8">
    
    <style>
      body { font-family: system-ui, sans-serif; max-width: 1100px; margin: 2rem auto; }
      nav { margin-bottom: 1rem; }
      table { width: 100%; border-collapse: collapse; margin-top: 1rem; }
      th, td { border: 1px solid #ccc; padding: .5rem; text-align: center; }
      th { background: #f0f0f0; }
      .flash-error { background: #f8d7da; color: #721c24; padding: .5rem; margin-bottom: 1rem; border: 1px solid #f5c6cb; }
      .flash-success { background: #d4edda; color: #155724; padding: .5rem; margin-bottom: 1rem; border: 1px solid #c3e6cb; }
      .elo-pos { color: green; font-weight: bold; }
      .elo-neg { color: red; font-weight: bold; }

      .btn-confirm {
        margin-top: 1rem;
        padding: .75rem 1.5rem;
        font-size: 1rem;
        background: #4CAF50;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        width: 100%;
      }
      .btn-confirm:hover { background: #45a049; }

      .btn-deck {
        padding: .3rem .6rem;
        font-size: 0.9rem;
        background: #007bff;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        margin: 2px;
      }
      .btn-deck:hover { background: #0069d9; }

      /* Grey variant for outside Top Cut */
      .btn-deck-grey {
        background: #6c757d;
        color: #f8f9fa;
      }
      .btn-deck-grey:hover { background: #5a6268; }

      .icon { margin-right: 4px; }

      /* Modal */
      .modal {
        display: none;
        position: fixed;
        z-index: 1000;
        left: 0; top: 0;
        width: 100%; height: 100%;
        background-color: rgba(0,0,0,0.5);
      }
      .modal-content {
        background-color: #fff;
        margin: 5% auto;
        padding: 20px;
        border-radius: 6px;
        width: 400px;
      }
      .modal-content h3 { margin-top: 0; }
      .modal-content input, .modal-content textarea {
        width: 100%;
        margin-bottom: 1rem;
        padding: .5rem;
        border: 1px solid #ccc;
        border-radius: 4px;
      }
      .close {
        float: right;
        font-size: 1.2rem;
        cursor: pointer;
      }
      tr.highlight { background-color: #ffeeba; font-weight: bold; }

      .side-panel {
        flex:0 0 200px;
        background:#f9f9f9;
        padding:1rem;
        border:1px solid #ccc;
        border-radius:6px;
      }

  .deck-editor-wrap {
    position: relative;
    border: 1px solid #ccc;
    border-radius: 4px;
    min-height: 200px;
    background: #fff;
    /* prevent width changes due to padding/border */
    box-sizing: border-box;
    overflow: hidden;
  }


.deck-editor {
  border: 1px solid #ccc;
  border-radius: 4px;
  min-height: 200px;
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Courier New", monospace;
  font-size: 14px;
  line-height: 1.5;
  padding: .5rem;
  white-space: pre-wrap;
  word-wrap: break-word;
  overflow: auto;
  outline: none;
  box-sizing: border-box;
}

/* Highlight spans behave exactly like text */
.hl-valid,
.hl-invalid,
.hl-dup {
  display: inline;
  font: inherit;
  line-height: inherit;
  vertical-align: baseline;
  padding: 0;
  margin: 0;
}

.hl-valid   { color: #2e7d32; }
.hl-invalid { background: #f8d7da; color: #c0392b; }
.hl-dup     { background: #ffeeba; color: #7f6000; }


      .side-panel h3 { margin-top:0; }

      .option-group { display: flex; flex-direction: column; gap: .5rem; }
      .option input[type="radio"] { display: none; }
      .option span {
        display: block;
        padding: .6rem 1rem;
        border: 1px solid #ccc;
        border-radius: 6px;
        cursor: pointer;
        background: #f9f9f9;
        transition: all 0.2s ease;
        text-align: center;
      }
      .option input[type="radio"]:checked + span {
        background: #4CAF50;
        color: white;
        border-color: #4CAF50;
        font-weight: bold;
      }
      .option span:hover { background: #e0e0e0; }
    </style>


    <h1>Tournament Round {{ round_num }}</h1>

    <nav>
      <a href="{{ url_for('new_tournament') }}">Create a new tournament</a>
    </nav>

    {% with messages = get_flashed_messages(with_categories=true) %}
      {% if messages %}
        {% for category, message in messages %}
          {% if category == 'error' %}
            <div class="flash-error">{{ message }}</div>
          {% elif category == 'success' %}
            <div class="flash-success">{{ message }}</div>
          {% endif %}
        {% endfor %}
      {% endif %}
    {% endwith %}
{% if tournament.imported_from_text %}
  <h2>This tournament was imported from EventLink text.</h2>
  <p>All rounds have already been recorded. Please review the final standings before Elo is applied.</p>

  {% if tournament.premium %}
    <p style="color:gold; font-weight:bold; margin-top:0.5rem;">
      ‚òÖ This is a Premium Event ‚òÖ
    </p>
  {% endif %}


      <div style="display:flex; gap:2rem;">
        <!-- Standings table -->
        <div style="flex:1;">
          <h2>Final Standings (Preview)</h2>
          <div id="playersMeta" data-count="{{ players|length }}"></div>

          <table>
            <tr>
              <th>Rank</th>
              <th>Player</th>
              <th>Wins</th>
              <th>Draws</th>
              <th>Losses</th>
              <th>Points</th>
              <th>Elo Œî</th>
              <th>Deck</th>
            </tr>
            {% for s in standings %}
            {% set in_cut = (tournament.top_cut is not none) and (loop.index <= tournament.top_cut|int) %}

            <tr data-rank="{{ loop.index }}" class="{% if in_cut %}highlight{% endif %}">
              <td>{{ loop.index }}</td>
              <td>{{ s.player.name }}</td>
              <td>{{ s.wins }}</td>
              <td>{{ s.draws }}</td>
              <td>{{ s.losses }}</td>
              <td>{{ s.points }}</td>
              <td>
                <span class="{{ 'elo-pos' if s.elo_delta > 0 else 'elo-neg' if s.elo_delta < 0 else '' }}">
                  {{ s.elo_delta }}
                </span>
              </td>
<td>
  {% if s.deck %}
    <!-- Edit deck button (always blue) -->
    <button class="btn-deck"
            data-player-id="{{ s.player.id }}"
            data-player-name="{{ s.player.name|e }}"
            data-deck-name="{{ s.deck.name|e }}"
            data-deck-list="{{ s.deck.list_text|e }}"
            onclick="openDeckModal(this)">
      <span class="icon">‚úèÔ∏è</span>Edit
    </button>
    <!-- Remove deck button (always blue) -->
    <form method="POST" action="{{ url_for('remove_deck') }}" style="display:inline;">
      <input type="hidden" name="player_id" value="{{ s.player.id }}">
      <input type="hidden" name="tournament_id" value="{{ tid }}">
      <button type="submit" class="btn-deck">
        <span class="icon">üóëÔ∏è</span>Remove
      </button>
    </form>
    
  {% else %}
    <!-- Add deck button: blue if in cut, grey if out -->
    <button class="btn-deck {% if not in_cut %}btn-deck-grey{% endif %}"
            data-player-id="{{ s.player.id }}"
            data-player-name="{{ s.player.name|e }}"
            onclick="openDeckModal(this)">
      <span class="icon">‚ûï</span>Add Deck
    </button>
  {% endif %}
</td>


            </tr>
            {% endfor %}
          </table>
        </div>
{% if tournament.pending and current_user.is_authenticated and (current_user.is_admin or current_user.is_scorekeeper) %}
<div class="side-panel">
  <h3>Playoff Cut</h3>
  <form method="POST" action="{{ url_for('apply_top_cut', tid=tid) }}" class="topcut-form">
    <div class="option-group">
      <label class="option">
        <input type="radio" name="top_cut" value="" {% if not tournament.top_cut %}checked{% endif %}>
        <span>Auto</span>
      </label>

      {% if players|length >= 4 %}
      <label class="option">
        <input type="radio" name="top_cut" value="4" {% if tournament.top_cut == 4 %}checked{% endif %}>
        <span>TOP 4</span>
      </label>
      {% endif %}

      {% if players|length >= 8 %}
      <label class="option">
        <input type="radio" name="top_cut" value="8" {% if tournament.top_cut == 8 %}checked{% endif %}>
        <span>TOP 8</span>
      </label>
      {% endif %}

      {% if players|length >= 16 %}
      <label class="option">
        <input type="radio" name="top_cut" value="16" {% if tournament.top_cut == 16 %}checked{% endif %}>
        <span>TOP 16</span>
      </label>
      {% endif %}

      {% if players|length >= 32 %}
      <label class="option">
        <input type="radio" name="top_cut" value="32" {% if tournament.top_cut == 32 %}checked{% endif %}>
        <span>TOP 32</span>
      </label>
      {% endif %}
    </div>
    <button type="submit" class="btn-confirm">Confirm and Apply Elo</button>
  </form>

<h3>Store</h3>
<select id="storeSelect" name="store_id">
  <option value="">-- Select Store --</option>
  {% for store in stores %}
    <option value="{{ store.id }}" {% if tournament.store_id == store.id %}selected{% endif %}>
      {{ store.name }}{% if store.location %} ({{ store.location }}{% if store.country %}, {{ store.country }}{% endif %}){% elif store.country %} ({{ store.country }}){% endif %}
    </option>
  {% endfor %}
</select>

<div id="storeStatus"></div>

<script>
document.getElementById("storeSelect").addEventListener("change", function() {
  const storeId = this.value;
  if (!storeId) return;
  fetch("{{ url_for('set_tournament_store', tid=tid) }}", {
    method: "POST",
    headers: { "Content-Type": "application/x-www-form-urlencoded" },
    body: new URLSearchParams({ store_id: storeId })
  }).then(() => {
    // After POST, the route redirects, but in fetch it won't follow in-page.
    // Optionally show a message, then reload for consistent state:
    document.getElementById("storeStatus").textContent = "Store updated. Reloading...";
    window.location.reload();
  });
});
</script>


</div>
{% endif %}



      <!-- Deck Modal -->
      <div id="deckModal" class="modal">
        <div class="modal-content">
          <span class="close" onclick="closeDeckModal()">&times;</span>
          <h3 id="deckModalTitle">Add Deck</h3>
          <form id="deckForm" method="POST" action="{{ url_for('submit_deck') }}">
            <input type="hidden" name="player_id" id="deckPlayerId">
            <input type="hidden" name="tournament_id" value="{{ tid }}">
            <label>Deck Name</label>
            <input type="text" name="deck_name" id="deckName">
<label>Deck List</label>
<div id="deckEditor" contenteditable="true" class="deck-editor"></div>

<!-- hidden textarea to submit raw text -->
<textarea name="deck_list" id="deckList" hidden></textarea>

<div id="deckErrors" style="color:red; margin-top:0.5rem;"></div>




            <button type="submit" class="btn-deck"><span class="icon">üíæ</span>Save</button>
          </form>
        </div>
      </div>

<script>
  // Modal open/close + populate
  function openDeckModal(button) {
    const playerId   = button.dataset.playerId;
    const playerName = button.dataset.playerName;
    const deckName   = button.dataset.deckName;
    const deckList   = button.dataset.deckList;

    const modal      = document.getElementById('deckModal');
    const title      = document.getElementById('deckModalTitle');
    const playerIdInput = document.getElementById('deckPlayerId');
    const deckNameInput = document.getElementById('deckName');
    const editor     = document.getElementById('deckEditor');
    const hidden     = document.getElementById('deckList');

    if (!modal || !title || !playerIdInput || !deckNameInput || !editor || !hidden) return;

    modal.style.display = 'block';
    title.textContent   = (deckName ? 'Edit Deck for ' : 'Add Deck for ') + playerName;
    playerIdInput.value = playerId;
    deckNameInput.value = deckName || '';

    const initial = deckList || '';
    editor.textContent = initial;   // raw text only
    hidden.value       = initial;
    debouncedValidate();            // initial render
  }

  function closeDeckModal() {
    const modal = document.getElementById('deckModal');
    if (modal) modal.style.display = 'none';
  }

  window.onclick = function(event) {
    const modal = document.getElementById('deckModal');
    if (event.target === modal) closeDeckModal();
  }

  // Top Cut highlight logic
  function updateHighlight(topCut) {
    const rows = document.querySelectorAll("tr[data-rank]");
    rows.forEach(row => {
      const rank = parseInt(row.dataset.rank, 10);
      if (topCut && rank <= topCut) row.classList.add("highlight");
      else row.classList.remove("highlight");

      const addBtn = row.querySelector("button.btn-deck");
      if (addBtn && addBtn.textContent.includes("Add Deck")) {
        if (topCut && rank <= topCut) addBtn.classList.remove("btn-deck-grey");
        else addBtn.classList.add("btn-deck-grey");
      }
    });
  }

  const playersMetaEl = document.getElementById('playersMeta');
  const numPlayers    = playersMetaEl ? parseInt(playersMetaEl.dataset.count, 10) : 0;

  function defaultTopCut(n) {
    let cut = 0;
    if (n >= 9 && n <= 16) cut = 4;
    else if (n >= 17 && n <= 32) cut = 8;
    else if (n >= 33 && n <= 64) cut = 8;
    else if (n >= 65 && n <= 128) cut = 8;
    else if (n >= 129 && n <= 226) cut = 8;
    else if (n >= 217 && n <= 256) cut = 16;
    else if (n >= 257 && n <= 512) cut = 16;
    else if (n >= 513 && n <= 1024) cut = 32;
    else if (n >= 1025 && n <= 2048) cut = 32;
    return Math.min(cut, n);
  }

  document.querySelectorAll("input[name='top_cut']").forEach(input => {
    input.addEventListener("change", () => {
      const val = input.value;
      let topCut = val === "" ? defaultTopCut(numPlayers) : parseInt(val, 10);
      topCut = Math.min(topCut, numPlayers);
      updateHighlight(topCut);
    });
  });

  const checked = document.querySelector("input[name='top_cut']:checked");
  if (checked) {
    const val = checked.value;
    let topCut = val === "" ? defaultTopCut(numPlayers) : parseInt(val, 10);
    topCut = Math.min(topCut, numPlayers);
    updateHighlight(topCut);
  }

  // --- Inline validation inside editor (supports multiple cards per line) ---
  const editor     = document.getElementById("deckEditor");
  const hidden     = document.getElementById("deckList");
  const deckErrors = document.getElementById("deckErrors");

  function debounce(fn, delay = 300) {
    let t;
    return (...args) => { clearTimeout(t); t = setTimeout(() => fn(...args), delay); };
  }

  // Ensure each child is a DIV with a SPAN without rebuilding all text
  function normalizeEditor() {
    Array.from(editor.childNodes).forEach(node => {
      if (node.nodeType === Node.TEXT_NODE) {
        const div = document.createElement("div");
        const span = document.createElement("span");
        span.textContent = node.textContent;
        div.appendChild(span);
        editor.replaceChild(div, node);
      } else if (node.nodeType === Node.ELEMENT_NODE && node.tagName !== "DIV") {
        const div = document.createElement("div");
        const span = document.createElement("span");
        span.textContent = node.textContent;
        div.appendChild(span);
        editor.replaceChild(div, node);
      } else if (node.nodeType === Node.ELEMENT_NODE && node.tagName === "DIV") {
        let span = node.querySelector("span");
        if (!span) {
          span = document.createElement("span");
          span.textContent = node.textContent;
          node.innerHTML = "";
          node.appendChild(span);
        }
      }
    });
    if (!editor.firstChild) {
      const div = document.createElement("div");
      const span = document.createElement("span");
      div.appendChild(span);
      editor.appendChild(div);
    }
  }

  // Extract individual card names from a line that may contain multiple entries
  function extractNamesFromLine(rawLine) {
    const tokens = rawLine.trim().split(/\s+/);
    const names = [];
    let current = [];

    for (let i = 0; i < tokens.length; i++) {
      const tok = tokens[i];
      const next = tokens[i + 1];

      if (/^\d+$/.test(tok)) {
        // count token: push any accumulated name before starting the next
        if (current.length > 0) {
          names.push(current.join(" "));
          current = [];
        }
        continue; // skip the count; next tokens belong to the name
      } else {
        current.push(tok);
        // if next token is a count or end of line, finalize current name
        if (!next || /^\d+$/.test(next)) {
          names.push(current.join(" "));
          current = [];
        }
      }
    }

    return names
      .map(n => n.trim())
      .filter(n => n.length > 0);
  }

  async function validateNames(cardNames) {
    const invalid = new Set();
    for (const name of cardNames) {
      try {
        const resp = await fetch(`https://api.scryfall.com/cards/named?exact=${encodeURIComponent(name)}`);
        const card = await resp.json();
        if (card.object === "error") invalid.add(name.toLowerCase());
      } catch {
        invalid.add(name.toLowerCase());
      }
    }
    return invalid;
  }

  async function validateAndHighlight() {
    if (!editor || !hidden || !deckErrors) return;

    normalizeEditor();

    const lines = Array.from(editor.children).map(div => div.querySelector("span").textContent);
    hidden.value = lines.join("\n");

    // Build full list of names across all lines, with duplicate detection
    const names = [];
    const seen = new Set();
    const dupSet = new Set();

    const perLineNames = lines.map(line => extractNamesFromLine(line));
    for (const arr of perLineNames) {
      for (const nm of arr) {
        const key = nm.toLowerCase();
        if (seen.has(key)) dupSet.add(key);
        else { seen.add(key); names.push(nm); }
      }
    }

    const invalidSet = await validateNames(names);

    // Decide line highlight: red if any invalid in that line, yellow if any duplicate (and no invalid), green otherwise
    perLineNames.forEach((arr, i) => {
      let isInvalid = false;
      let isDup = false;
      for (const nm of arr) {
        const key = nm.toLowerCase();
        if (invalidSet.has(key)) { isInvalid = true; break; }
        if (dupSet.has(key)) isDup = true;
      }
      const cls = isInvalid ? "hl-invalid" : (isDup ? "hl-dup" : "hl-valid");

      const span = editor.children[i].querySelector("span");
      if (span.className !== cls) span.className = cls;
    });

    // Errors list for invalid names (unique)
    deckErrors.innerHTML = "";
    if (invalidSet.size > 0) {
      const done = new Set();
      for (const nm of names) {
        const key = nm.toLowerCase();
        if (invalidSet.has(key) && !done.has(key)) {
          const div = document.createElement("div");
          div.textContent = `${nm} ‚Üí not found (exact match)`;
          deckErrors.appendChild(div);
          done.add(key);
        }
      }
    }
  }

  const debouncedValidate = debounce(validateAndHighlight, 300);

  if (editor) {
    normalizeEditor();
    editor.addEventListener("input", debouncedValidate);
    editor.addEventListener("blur", validateAndHighlight);
    editor.addEventListener("keydown", e => {
      if (e.key === "Enter") {
        setTimeout(() => normalizeEditor(), 0);
      }
    });

  // üëá Add this paste handler here
  editor.addEventListener("paste", e => {
    e.preventDefault();
    const text = (e.clipboardData || window.clipboardData).getData("text");
    const lines = text.replace(/\r/g, "").split("\n");

    // Insert each line as its own div/span
    lines.forEach(line => {
      const div = document.createElement("div");
      const span = document.createElement("span");
      span.textContent = line;
      div.appendChild(span);
      editor.appendChild(div);
    });

    // After paste, normalize and validate
    normalizeEditor();
    debouncedValidate();
  });
}


</script>




    {% else %}
      <h2>Enter Matches for Round {{ round_num }}</h2>
      <form method="POST">
        <table>
          <tr>
            <th>Player 1</th>
            <th>Player 2</th>
            <th>Result</th>
          </tr>
          {% for i in range(1, (players|length + 1)//2 + 1) %}
          <tr>
            <td>
              <select name="player1_{{ i }}">
                <option value="">-Select Player-</option>
                {% for p in players %}
                  <option value="{{ p.id }}">{{ p.name }}</option>
                {% endfor %}
                {% if (players|length) % 2 == 1 %}
                  <option value="bye">Bye</option>
                {% endif %}
              </select>
            </td>
            <td>
              <select name="player2_{{ i }}">
                <option value="">-Select Player-</option>
                {% for p in players %}
                  <option value="{{ p.id }}">{{ p.name }}</option>
                {% endfor %}
                {% if (players|length) % 2 == 1 %}
                  <option value="bye">Bye</option>
                {% endif %}
              </select>
            </td>
            <td>
              <select name="result_{{ i }}">
                <option value="2-0">2-0</option>
                <option value="2-1">2-1</option>
                <option value="1-2">1-2</option>
                <option value="0-2">0-2</option>
                <option value="1-1">1-1</option>
                <option value="1-0">1-0</option>
                <option value="0-1">0-1</option>
              </select>
            </td>
          </tr>
          {% endfor %}
        </table>
        <button type="submit">Submit Round {{ round_num }}</button>
      </form>
    {% endif %}

  {% endblock %}

