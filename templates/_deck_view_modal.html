<!-- Deck View Modal -->
<div id="deckModal" class="modal">
  <div class="modal-content-deck">
    <h3 id="deckModalTitle">
      <span id="deckTitleText">Deck</span>
      <i class="material-icons copy-deck-icon" onclick="copyDeckToClipboard(event)" title="Copy deck list to clipboard">content_copy</i>
      <span class="close" onclick="closeDeckModal()">&times;</span>
    </h3>
    
    <div class="deck-modal-panels">
      <!-- Left Panel: Main Deck -->
      <div class="deck-panel deck-panel-left">
        <h4><i class="material-icons" style="vertical-align: middle; font-size: 20px;">layers</i> Main Deck</h4>
        <ul id="mainDeck" class="card-list-enhanced"></ul>
      </div>
      
      <!-- Middle Panel: Sideboard -->
      <div class="deck-panel deck-panel-middle">
        <h4><i class="material-icons" style="vertical-align: middle; font-size: 20px;">inventory_2</i> Sideboard</h4>
        <ul id="sideboard" class="card-list-enhanced"></ul>
      </div>
      
      <!-- Right Panel: Card Info -->
      <div class="deck-panel deck-panel-right">
        <div id="cardInfoPanel" class="card-info-panel">
          <div class="card-image-container">
            <img id="cardPreview" src="" alt="Select a card" style="display: none;">
          </div>
          <div id="cardDetails" class="card-details">
            <h4 id="cardName">Select a card</h4>
            <div class="card-detail-row">
              <span class="detail-label"><i class="material-icons">attach_money</i> Price:</span>
              <span id="cardPrice" class="detail-value">–</span>
            </div>
            <div class="card-detail-row">
              <span class="detail-label"><i class="material-icons">star</i> CMC:</span>
              <span id="cardCmc" class="detail-value">–</span>
            </div>
            <div class="card-detail-row">
              <span class="detail-label"><i class="material-icons">library_books</i> Type:</span>
              <span id="cardType" class="detail-value">–</span>
            </div>
            <div class="card-detail-row">
              <span class="detail-label"><i class="material-icons">gavel</i> Legality:</span>
              <span id="cardLegality" class="detail-value">–</span>
            </div>
            <div class="card-detail-row oracle-text-row">
              <span class="detail-label"><i class="material-icons">description</i> Oracle Text:</span>
            </div>
            <div class="oracle-text-content">
              <span id="cardOracleText" class="detail-value">–</span>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
  let firstCardInDeck = null;
  let currentImageLoadId = 0; // Track image load requests to prevent race conditions
  let hasAutoSelected = false; // Track if we've already auto-selected a card

  function openDeckModal(row) {
    const playerName = JSON.parse(row.dataset.playerName || '""');
    const deckName   = JSON.parse(row.dataset.deckName || '""');
    const deckList   = JSON.parse(row.dataset.deckList || '""');

    if (!deckName) return;

    document.getElementById('deckModal').style.display = 'block';
    document.getElementById('deckTitleText').textContent = deckName + " (" + playerName + ")";

    const mainDeck = document.getElementById('mainDeck');
    const sideboard = document.getElementById('sideboard');
    mainDeck.innerHTML = "";
    sideboard.innerHTML = "";
    resetCardPanel();
    firstCardInDeck = null;
    hasAutoSelected = false; // Reset auto-select flag for new modal open

    const lines = deckList.split(/\r?\n/).filter(l => l.trim() !== "");
    let inSideboard = false;

    // Store card data grouped by type
    const mainDeckCards = {
      Creature: [],
      Planeswalker: [],
      Artifact: [],
      Enchantment: [],
      Instant: [],
      Sorcery: [],
      Land: [],
      Other: []
    };
    const sideboardCards = [];

    // Parse all lines and fetch card data
    const fetchPromises = [];

    lines.forEach(line => {
      if (/^sideboard/i.test(line.trim())) {
        inSideboard = true;
        return;
      }
      const parts = line.trim().split(/\s+/, 2);
      const count = parts[0];
      const name = line.trim().substring(count.length).trim();

      if (!name) return;

      // Capture the current sideboard state for this specific card
      const isInSideboard = inSideboard;

      const promise = fetch(`https://api.scryfall.com/cards/named?fuzzy=${encodeURIComponent(name)}`)
        .then(res => res.json())
        .then(card => {
          const cardData = { name, count, card, isInSideboard };
          
          if (isInSideboard) {
            sideboardCards.push(cardData);
          } else {
            // Determine card type category
            const typeLine = (card.type_line || '').toLowerCase();
            if (typeLine.includes('creature')) {
              mainDeckCards.Creature.push(cardData);
            } else if (typeLine.includes('planeswalker')) {
              mainDeckCards.Planeswalker.push(cardData);
            } else if (typeLine.includes('artifact')) {
              mainDeckCards.Artifact.push(cardData);
            } else if (typeLine.includes('enchantment')) {
              mainDeckCards.Enchantment.push(cardData);
            } else if (typeLine.includes('instant')) {
              mainDeckCards.Instant.push(cardData);
            } else if (typeLine.includes('sorcery')) {
              mainDeckCards.Sorcery.push(cardData);
            } else if (typeLine.includes('land')) {
              mainDeckCards.Land.push(cardData);
            } else {
              mainDeckCards.Other.push(cardData);
            }
          }
        })
        .catch(err => console.error("Scryfall fetch error", err));

      fetchPromises.push(promise);
    });

    // Wait for all fetches to complete, then render
    Promise.all(fetchPromises).then(() => {
      console.log('=== Starting to render deck ===');
      // Render main deck with type dividers
      const typeOrder = ['Creature', 'Planeswalker', 'Artifact', 'Enchantment', 'Instant', 'Sorcery', 'Land', 'Other'];
      
      typeOrder.forEach(type => {
        const cards = mainDeckCards[type];
        if (cards.length === 0) return; // Skip empty types
        
        // Calculate total count for this type
        const totalCount = cards.reduce((sum, c) => sum + parseInt(c.count), 0);
        
        // Create type divider
        const divider = document.createElement('li');
        divider.className = 'type-divider';
        divider.textContent = `${type} (${totalCount})`;
        mainDeck.appendChild(divider);
        
        // Add cards of this type
        cards.forEach(cardData => {
          const li = createCardListItem(cardData.name, cardData.count, cardData.card, false);
          mainDeck.appendChild(li);
        });
      });

      // Render sideboard
      sideboardCards.forEach(cardData => {
        const li = createCardListItem(cardData.name, cardData.count, cardData.card, true);
        sideboard.appendChild(li);
      });
      
      console.log('=== About to call adjustListSize ===');
      console.log('Main deck children:', mainDeck.querySelectorAll('li').length);
      console.log('Sideboard children:', sideboard.querySelectorAll('li').length);
      
      // Adjust font sizes to prevent scrolling
      adjustListSize(mainDeck);
      adjustListSize(sideboard);
    });
  }
  
  function adjustListSize(listElement) {
    // Count total items including dividers
    const totalItems = listElement.querySelectorAll('li').length;
    const dividerCount = listElement.querySelectorAll('li.type-divider').length;
    
    console.log('Total items:', totalItems, 'Dividers:', dividerCount);
    
    if (totalItems === 0) return;
    
    // Base font size, padding, and margins - start larger for smaller lists
    let fontSize = 1.0; // rem - increased default
    let padding = 0.4; // rem - increased default
    let cardMargin = 0.12; // rem - increased default
    let dividerMarginTop = 0.35; // rem
    let dividerMarginBottom = 0.25; // rem
    let dividerPadding = 0.22; // rem - keep compact
    let dividerFontSize = 0.8; // rem
    
    // Adjust based on item count (including dividers)
    // Only scale down when necessary
    if (totalItems > 70) {
      fontSize = 0.55;
      padding = 0.18;
      cardMargin = 0.04;
      dividerMarginTop = 0.15;
      dividerMarginBottom = 0.12;
      dividerPadding = 0.15;
      dividerFontSize = 0.55;
    } else if (totalItems > 60) {
      fontSize = 0.6;
      padding = 0.2;
      cardMargin = 0.05;
      dividerMarginTop = 0.18;
      dividerMarginBottom = 0.14;
      dividerPadding = 0.17;
      dividerFontSize = 0.6;
    } else if (totalItems > 50) {
      fontSize = 0.65;
      padding = 0.22;
      cardMargin = 0.06;
      dividerMarginTop = 0.22;
      dividerMarginBottom = 0.16;
      dividerPadding = 0.19;
      dividerFontSize = 0.63;
    } else if (totalItems > 40) {
      fontSize = 0.7;
      padding = 0.24;
      cardMargin = 0.07;
      dividerMarginTop = 0.25;
      dividerMarginBottom = 0.18;
      dividerPadding = 0.2;
      dividerFontSize = 0.67;
    } else if (totalItems > 30) {
      fontSize = 0.75;
      padding = 0.26;
      cardMargin = 0.08;
      dividerMarginTop = 0.28;
      dividerMarginBottom = 0.2;
      dividerPadding = 0.21;
      dividerFontSize = 0.7;
    } else if (totalItems > 25) {
      fontSize = 0.8;
      padding = 0.28;
      cardMargin = 0.09;
      dividerMarginTop = 0.3;
      dividerMarginBottom = 0.22;
      dividerPadding = 0.22;
      dividerFontSize = 0.73;
    } else if (totalItems > 20) {
      fontSize = 0.85;
      padding = 0.32;
      cardMargin = 0.1;
      dividerMarginTop = 0.32;
      dividerMarginBottom = 0.23;
      dividerPadding = 0.22;
      dividerFontSize = 0.75;
    } else if (totalItems > 15) {
      fontSize = 0.9;
      padding = 0.35;
      cardMargin = 0.11;
      dividerMarginTop = 0.33;
      dividerMarginBottom = 0.24;
      dividerPadding = 0.22;
      dividerFontSize = 0.77;
    } else if (totalItems > 10) {
      fontSize = 0.95;
      padding = 0.37;
      cardMargin = 0.115;
      dividerMarginTop = 0.34;
      dividerMarginBottom = 0.24;
      dividerPadding = 0.22;
      dividerFontSize = 0.78;
    }
    // If 10 or fewer items, use the larger default values
    
    // Apply styles to all list items
    listElement.querySelectorAll('li').forEach(li => {
      if (li.classList.contains('type-divider')) {
        // Adjust divider-specific spacing - keep them compact
        li.style.fontSize = dividerFontSize + 'rem';
        li.style.padding = dividerPadding + 'rem 1rem'; // Wider padding
        li.style.marginTop = dividerMarginTop + 'rem';
        li.style.marginBottom = dividerMarginBottom + 'rem';
      } else {
        // Adjust card item spacing
        li.style.fontSize = fontSize + 'rem';
        li.style.padding = padding + 'rem 0.5rem';
        li.style.marginBottom = cardMargin + 'rem';
      }
    });
    
    console.log('Applied fontSize:', fontSize, 'dividerFontSize:', dividerFontSize);
  }

  function createCardListItem(name, count, card, isInSideboard) {
    const li = document.createElement('li');
    const cardNameSpan = document.createElement('span');
    cardNameSpan.className = 'card-name-text';
    cardNameSpan.textContent = count + " " + name;
    li.appendChild(cardNameSpan);

    if (card.mana_cost) {
      const manaSpan = document.createElement('span');
      manaSpan.className = 'card-mana-cost';
      manaSpan.innerHTML = renderManaCost(card.mana_cost);
      li.appendChild(manaSpan);
    }
    
    li.addEventListener('click', () => {
      document.querySelectorAll('.card-list-enhanced li').forEach(el => el.classList.remove('selected'));
      li.classList.add('selected');
      displayCardInfo(card);
    });

    // Auto-select first card in main deck
    if (!isInSideboard && !hasAutoSelected) {
      hasAutoSelected = true;
      firstCardInDeck = li;
      setTimeout(() => {
        li.classList.add('selected');
        displayCardInfo(card);
      }, 200);
    }

    return li;
  }

  function resetCardPanel() {
    const preview = document.getElementById('cardPreview');
    preview.src = '';
    preview.style.display = 'none';
    preview.style.opacity = '0';
    document.getElementById('cardName').textContent = 'Select a card';
    document.getElementById('cardPrice').textContent = '–';
    document.getElementById('cardCmc').textContent = '–';
    document.getElementById('cardType').textContent = '–';
    document.getElementById('cardOracleText').innerHTML = '–';
    document.getElementById('cardLegality').textContent = '–';
  }

  function renderOracleText(text) {
    if (!text || !symbolMap) return text;
    
    // Escape HTML first to prevent XSS
    const escaped = text
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;');
    
    // Replace mana symbols {X} with Scryfall SVG icons
    return escaped.replace(/\{([^}]+)\}/g, (match, symbol) => {
      const symbolKey = `{${symbol}}`;
      const uri = symbolMap[symbolKey];
      if (uri) {
        return `<img src="${uri}" alt="${symbolKey}" class="mana-icon-inline" title="${symbolKey}">`;
      }
      return match;
    });
  }

  function displayCardInfo(card) {
    console.log('Displaying card:', card.name);
    
    // Increment load ID to invalidate previous requests
    currentImageLoadId++;
    const myLoadId = currentImageLoadId;
    
    // Get preview element
    const preview = document.getElementById('cardPreview');
    
    // Check if we're currently showing an image (before fading out)
    const wasVisible = preview.style.display === 'block' && preview.style.opacity === '1';
    
    // Fade out current image
    preview.style.opacity = '0';
    preview.style.transition = 'opacity 0.3s ease-in-out';
    
    // Fetch all printings to find oldest and cheapest
    fetch(`https://api.scryfall.com/cards/search?q=!"`+encodeURIComponent(card.name)+`" -set:lea -set:leb -set:2ed -set:3ed -set:ced -set:cei -set:fbb -set:sum&unique=prints&order=released&dir=asc`)
      .then(res => res.json())
      .then(data => {
        // Check if this request is still current
        if (myLoadId !== currentImageLoadId) return;
        
        const editions = data.data || [];
        
        // Get oldest card image (first in the sorted list)
        let imgUrl = "";
        if (editions.length > 0) {
          const oldestCard = editions[0];
          if (oldestCard.image_uris?.normal) {
            imgUrl = oldestCard.image_uris.normal;
          } else if (oldestCard.card_faces?.[0]?.image_uris?.normal) {
            imgUrl = oldestCard.card_faces[0].image_uris.normal;
          }
        }
        
        console.log('Image URL (oldest):', imgUrl);
        
        if (imgUrl && myLoadId === currentImageLoadId) {
          // Preload image before doing anything
          const tempImg = new Image();
          tempImg.onload = () => {
            // Double-check we're still on the same card
            if (myLoadId !== currentImageLoadId) return;
            
            // Wait for fade-out to complete before changing the src
            const fadeOutDelay = wasVisible ? 300 : 0;
            setTimeout(() => {
              if (myLoadId !== currentImageLoadId) return;
              
              // Change the image source while opacity is 0
              preview.src = imgUrl;
              preview.style.display = 'block';
              
              // Small delay to ensure the src change has taken effect, then fade in
              setTimeout(() => {
                if (myLoadId === currentImageLoadId) {
                  preview.style.opacity = '1';
                }
              }, 50);
            }, fadeOutDelay);
          };
          tempImg.onerror = () => {
            console.error('Failed to load card image:', imgUrl);
            preview.style.display = 'none';
          };
          tempImg.src = imgUrl;
        } else if (myLoadId === currentImageLoadId) {
          preview.src = '';
          preview.style.display = 'none';
          preview.style.opacity = '0';
        }
        
        // Find cheapest price across all printings
        let cheapestPrice = null;
        editions.forEach(edition => {
          const usd = parseFloat(edition.prices?.usd);
          const usdFoil = parseFloat(edition.prices?.usd_foil);
          
          if (!isNaN(usd) && usd > 0) {
            if (cheapestPrice === null || usd < cheapestPrice) {
              cheapestPrice = usd;
            }
          }
          if (!isNaN(usdFoil) && usdFoil > 0) {
            if (cheapestPrice === null || usdFoil < cheapestPrice) {
              cheapestPrice = usdFoil;
            }
          }
        });
        
        // Display price
        document.getElementById('cardPrice').textContent = cheapestPrice !== null ? `$${cheapestPrice.toFixed(2)}` : 'N/A';
      })
      .catch(() => {
        // Check if this request is still current
        if (myLoadId !== currentImageLoadId) return;
        
        // Fallback to original card data if editions fetch fails
        let imgUrl = "";
        if (card.image_uris?.normal) {
          imgUrl = card.image_uris.normal;
        } else if (card.card_faces?.[0]?.image_uris?.normal) {
          imgUrl = card.card_faces[0].image_uris.normal;
        }
        
        if (imgUrl && myLoadId === currentImageLoadId) {
          const tempImg = new Image();
          tempImg.onload = () => {
            if (myLoadId !== currentImageLoadId) return;
            preview.src = imgUrl;
            preview.style.display = 'block';
            setTimeout(() => {
              if (myLoadId === currentImageLoadId) {
                preview.style.opacity = '1';
              }
            }, 50);
          };
          tempImg.src = imgUrl;
        }
        
        const price = card.prices?.usd || card.prices?.usd_foil;
        document.getElementById('cardPrice').textContent = price ? `$${price}` : 'N/A';
      });
    
    // Display card name
    document.getElementById('cardName').textContent = card.name;
    
    // Display CMC
    document.getElementById('cardCmc').textContent = card.cmc !== undefined ? card.cmc : '–';
    
    // Display type
    document.getElementById('cardType').textContent = card.type_line || '–';
    
    // Display oracle text
    let oracleText = card.oracle_text || '–';
    // Handle double-faced cards
    if (!card.oracle_text && card.card_faces && card.card_faces.length > 0) {
      oracleText = card.card_faces.map(face => 
        `${face.name}: ${face.oracle_text || ''}`
      ).join('\n\n');
    }
    
    // Replace mana symbols with Scryfall icons
    const oracleTextElement = document.getElementById('cardOracleText');
    if (oracleText !== '–') {
      oracleTextElement.innerHTML = renderOracleText(oracleText);
    } else {
      oracleTextElement.textContent = oracleText;
    }
    
    // Display legality (Premodern)
    const legality = card.legalities?.premodern || 'unknown';
    const legalityEl = document.getElementById('cardLegality');
    legalityEl.textContent = legality.charAt(0).toUpperCase() + legality.slice(1);
    legalityEl.className = 'detail-value legality-' + legality;
  }

  function closeDeckModal() {
    document.getElementById('deckModal').style.display = 'none';
    document.getElementById('mainDeck').innerHTML = "";
    document.getElementById('sideboard').innerHTML = "";
    resetCardPanel();
  }
  
  function copyDeckToClipboard(event) {
    const mainDeck = document.getElementById('mainDeck');
    const sideboard = document.getElementById('sideboard');
    
    let deckText = '';
    
    // Copy main deck
    mainDeck.querySelectorAll('li').forEach(li => {
      // Skip dividers
      if (li.classList.contains('type-divider')) return;
      
      const cardText = li.querySelector('.card-name-text');
      if (cardText) {
        deckText += cardText.textContent.trim() + '\n';
      }
    });
    
    // Add sideboard if it has cards
    const sideboardCards = sideboard.querySelectorAll('li:not(.type-divider)');
    if (sideboardCards.length > 0) {
      deckText += '\nSideboard\n';
      sideboardCards.forEach(li => {
        const cardText = li.querySelector('.card-name-text');
        if (cardText) {
          deckText += cardText.textContent.trim() + '\n';
        }
      });
    }
    
    // Copy to clipboard
    navigator.clipboard.writeText(deckText.trim()).then(() => {
      // Visual feedback
      const icon = event.target;
      const originalIcon = icon.textContent;
      icon.textContent = 'check';
      icon.style.color = '#4CAF50';
      setTimeout(() => {
        icon.textContent = originalIcon;
        icon.style.color = '';
      }, 1500);
    }).catch(err => {
      console.error('Failed to copy:', err);
      alert('Failed to copy deck list to clipboard');
    });
  }

  window.onclick = function(event) {
    if (event.target == document.getElementById('deckModal')) {
      closeDeckModal();
    }
  }
</script>
